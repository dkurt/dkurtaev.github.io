<!DOCTYPE html>
<html lang="en">

<head>
  <title>DK: Multi GLUT</title>
</head>

<body>

<h1><a href="index.html">Dmitry Kurtaev/</a> C++: Multiply GLUT windows</h1>
<p>
<b>Problem:</b> use separate GLUT windows with own callbacks and drawing functions.<br>
<b>Example:</b> written on C++, freeglut.<br>
<b>Languages:</b>
<a href="multiply_glut_windows.html">EN</a>,
<a href="multiply_glut_windows_ru.html">RU</a>
</p>

<p>
<h2>Single classic window</h2>
GLUT is a library for OpenGL.
It provides windows manipulations: create, reshape, receive user's callbacks and
display OpenGL's drawings stored in buffers.<br>
Minimal usage includes GLUT and window initialization, settings up references to
functions which we want to be called by specific events.
There are callbacks.<br>
Idle function is a function which must be called when no events exists. We set
display function as Idle.
</p>

<table>
  <td width="50%" valign="bottom">
  <pre>
  #include &lt;GL/freeglut.h&gt;

  int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);  // GLUT initialization.

    // Window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    int window_id = glutCreateWindow("Single view");

    // Set callbacks.
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutIdleFunc(display);

    glutMainLoop();  // Start GLUT's internal loop. Exit by window closing.
    return 0;
  }
  </pre></td>

  <td width="50%" valign="bottom">
  <pre>
  void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);  // Hex just for fun. Color is (202, 255, 238).
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();

    glutSwapBuffers();
  }

  void reshape(int width, int height) {
    glViewport(0, 0, width, height);
  }
  </pre></td>
</table>

<p>
Created window inherits OS's windows style.
At pictures example runned on Ubuntu 16.04LTS.<br>
<img src="images/single_window_triangle.png" alt="Single view"><br>
Addition: GLUT is a powerful but simple windows manager. We can not make some
OS-like operations like hiding window's header or keep window always on top of
other windows.
</p>

<h2>Two classic windows</h2>
<!-- Давайте подумаем о создании второго окна, отображающего иное содержимое.
Посмотрите внимательнее на пример выше. Мы назвали его минимальным, но это не
совсет так. Переменная window_id, получающая идентификатор окна от функции
glutCreateWindow(), нигде более не используется.
Русскому писателю Антону П. Чехову принадлежит высказывание
"Если в первом акте зрителю демонстрируется ружьё, значит во втором акте это
ружьё выстрелит.".
Приглашаю во второй акт, переменная window_id - и есть наше ружьё, которым мы
воспользуемся при решении поставленной задачи. -->

<!-- Проинициализируем последовательно два окна, каждое свяжем с собственной
функцией отрисовки. -->
We initializing two windows sequently. For each write own display function.
Before display instructions call glutSetWindow(..) with passed id of
 <!-- С id окна, в котором будет производиться перерисовка. -->
<!-- Обратить внимание на то, что два дисплея и один reshape. Для нашего примера,
изменение размера окна происходит только от лица пользователя. Перед этим,
пользователь выделяет окно как текущее, поэтому нам не нужно переключаться автоматически.
GLUT имеет функционал по программному запросу изменения размеров окна. В таком случае
и выделение окна как текущего требуется программное. -->
<!-- Посколько функии отрисовки объявлены как Idle, они исполняются циклично: когда
окно активно, скрыто или находится на заднем плане. См. рисунок, First View выделено,
Second View нет. Находясь в едином контексте, необходимо предварительно переключиться
между окнами. Для reshape, переключение осуществляет пользователь, нажатием мыши.
Для display мы должны перерисовывать как текущее, выделенное, окно, так и все
созданные. -->
<!-- Add second id and switch between. Tell about single reshape. What if number of view more than two? Additional ids?<br> -->
<table>
  <td width="50%" valign="bottom">
  <pre>
  int first_window_id, second_window_id;

  int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);  // GLUT initialization.

    // First window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    first_window_id = glutCreateWindow("First view");

    glutDisplayFunc(display_first);
    glutReshapeFunc(reshape);
    glutIdleFunc(display_first);

    // Second window initialization.
    glutInitWindowSize(324, 324);
    glutInitWindowPosition(500, 0);
    second_window_id = glutCreateWindow("Second view");

    glutDisplayFunc(display_second);
    glutReshapeFunc(reshape);
    glutIdleFunc(display_second);

    glutMainLoop();  // Exit from GLUT's loop by one of windows is closing.
    return 0;
  }

  void reshape(int width, int height) {
    glViewport(0, 0, width, height);
  }
  </pre></td>

  <td width="50%" valign="bottom">
  <pre>
  void display_first() {
    glutSetWindow(first_window_id);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();

    glutSwapBuffers();
  }

  void display_second() {
    glutSetWindow(second_window_id);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, -0.5f);
      glVertex2f(0.5f, 0.5f);
      glVertex2f(-0.5f, 0.5f);
    glEnd();

    glutSwapBuffers();
  }
  </pre></td>
</table>

<img src="images/two_windows_classic.png" alt="Two views"><br>

<h2>Single window as class object</h2>
<p>
Generally, problem is solved. But in future we may want to have more than two
windows and with more harder display logic. Let's try encapsulate window
managment inside class for more scalability.<br>
Make step backward to single window problem and implement class with same usage.
</p>
<pre>
class GLView {
 public:
   GLView(const char* title);

 private:
   static void display();
   static void reshape(int width, int height);
};
</pre>

<p>
Header of our class has all that we need. User choose window title only.
Now main function use single line for create similar window. In sight of class
user it is straight-forward usage without care about internal implementation.
</p>

<pre>
int main(int argc, char** argv) {
  GLView glview("Single view");
  glutMainLoop();
  return 0;
}
</pre>

In sight of class we just encpsulated existing usage inside corresponding
methods. Note that functions is static. It is required for registering
callbacks.
<table>
  <td width="50%" valign="bottom">
  <pre>
  GLView::GLView(const char* title) {
    // GLUT initialization.
    int argc = 0;
    glutInit(&amp;argc, 0);

    // Window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    int window_id = glutCreateWindow(title);

    // Set callbacks.
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutIdleFunc(display);
  }
  </pre></td>

  <td width="50%" valign="bottom">
  <pre>
  void GLView::display() {
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();

    glutSwapBuffers();
  }

  void GLView::reshape(int width, int height) {
    glViewport(0, 0, width, height);
  }
  </pre></td>
</table>

<h2>Abstract views manager</h2>

<pre>
class GLView {
 public:
   GLView(const char* title);

 protected:
   virtual void display() = 0;

 private:
   static void idle_display();
   static void reshape(int width, int height);

   static std::vector&lt;GLView*&gt; glviews;
   int window_id;
};
</pre>

<table>
  <td width="50%" valign="bottom">
  <pre>
  GLView::GLView(const char* title) {
    if (glviews.empty()) {
      int argc = 0;
      glutInit(&amp;argc, 0);  // GLUT initialization.
    }

    // Window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    window_id = glutCreateWindow(title);
    glviews.push_back(this);

    // Set callbacks.
    glutDisplayFunc(idle_display);
    glutReshapeFunc(reshape);
    glutIdleFunc(idle_display);
  }
  </pre></td>

  <td width="50%" valign="top">
  <pre>
  void GLView::idle_display() {
    for (int i = 0; i < glviews.size(); ++i) {
      glutSetWindow(glviews[i]->window_id);
      glviews[i]->display();
    }
  }

  void GLView::reshape(int width, int height) {
    glViewport(0, 0, width, height);
  }
  </pre></td>
</table>

<table>
  <td width="50%" valign="bottom">
  <pre>
  class FirstView : public GLView {
   public:
    FirstView() : GLView("First view") {}

   protected:
     virtual void display() {
       glClear(GL_COLOR_BUFFER_BIT);

       glColor3ub(0xCA, 0xFF, 0xEE);
       glBegin(GL_TRIANGLES);
         glVertex2f(0.0f, 0.5f);
         glVertex2f(-0.5f, -0.5f);
         glVertex2f(0.5f, -0.5f);
       glEnd();

       glutSwapBuffers();
     }
  };
  </pre></td>

  <td width="50%" valign="bottom">
  <pre>
  class SecondView : public GLView {
   public:
    SecondView() : GLView("Second view") {}

   protected:
     virtual void display() {
       glClear(GL_COLOR_BUFFER_BIT);

       glColor3ub(0xCA, 0xFF, 0xEE);
       glBegin(GL_TRIANGLES);
         glVertex2f(0.0f, -0.5f);
         glVertex2f(0.5f, 0.5f);
         glVertex2f(-0.5f, 0.5f);
       glEnd();

       glutSwapBuffers();
     }
  };
  </pre></td>
</table>

<h2>GLUT subwindows</h2>

<h2>Useful links</h2>
<!-- OpenGL Documentation -->
<!-- List of freeglut functions -->

</body>
</html>
