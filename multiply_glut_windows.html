<!DOCTYPE html>
<html lang="en">

<head>
  <title>DK: Multi GLUT</title>
</head>

<body>

<h1><a href="index.html">Dmitry Kurtaev/</a> C++: Multiply GLUT windows</h1>
<p>
<b>Problem:</b> use separate GLUT windows with own callbacks and drawing functions.<br>
<b>Example:</b> written on C++, freeglut.<br>
<b>Languages:</b>
<a href="multiply_glut_windows.html">EN</a>,
<a href="multiply_glut_windows_ru.html">RU</a>
</p>

<h2>Table of contents</h2>
&bull; <a href="#single_window">Single classic window</a><br>
&bull; <a href="#two_windows">Two classic windows</a><br>
&bull; <a href="#single_glview">Single window as class object</a><br>
&bull; <a href="#two_glviews">Abstract views manager</a><br>
&bull; <a href="#subwindows">GLUT subwindows</a><br>
&bull; <a href="#references">Useful links</a>

<p>
<h2 id="single_window">Single classic window</h2>
GLUT is a library for OpenGL.
It provides windows manipulations: create, reshape, receive user's callbacks and
display OpenGL's drawings stored in buffers.<br>
Minimal usage includes GLUT and window initialization, settings references to
callback functions by specific events.
</p>

<table>
  <td width="50%" valign="bottom">
  <pre><code>
  #include &lt;GL/freeglut.h&gt;

  int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);  // GLUT initialization.

    // Window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    int window_id = glutCreateWindow("Single view");

    glutDisplayFunc(display);  // Set callback.

    glutMainLoop();  // Start GLUT's internal loop. Exit by window closing.
    return 0;
  }
  </code></pre></td>

  <td width="50%" valign="bottom">
  <pre><code>
  void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);  // Hex just for fun. Color is (202, 255, 238).
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();

    glutSwapBuffers();
  }
  </code></pre></td>
</table>

<p>
Created window inherits OS's windows style.
At pictures it is running on Ubuntu 16.04LTS.<br>
<img src="images/single_window_triangle.png" alt="Single view"><br>
Addition: GLUT is a powerful but simple windows manager. We can not make some
OS-like operations like hiding window's header or keep window always on top of
other windows.
</p>

<h2 id="two_windows">Two classic windows</h2>
<p>
We initializing two windows sequently. For each write own display function.
</p>

<table>
  <td width="50%" valign="bottom">
  <pre><code>
  int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);  // GLUT initialization.

    // First window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    int first_window_id = glutCreateWindow("First view");

    glutDisplayFunc(display_first);

    // Second window initialization.
    glutInitWindowSize(324, 324);
    glutInitWindowPosition(500, 0);
    int second_window_id = glutCreateWindow("Second view");

    glutDisplayFunc(display_second);

    // Start GLUT's internal loop. Exit by one of windows is closing.
    glutMainLoop();
    return 0;
  }
  </code></pre></td>

  <td width="50%" valign="bottom">
  <pre><code>
  void display_first() {
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();
    glutSwapBuffers();
  }

  void display_second() {
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, -0.5f);
      glVertex2f(0.5f, 0.5f);
      glVertex2f(-0.5f, 0.5f);
    glEnd();
    glutSwapBuffers();
  }
  </code></pre></td>
</table>

<img src="images/two_windows_classic.png" alt="Two views"><br>

<h2 id="single_glview">Single window as class object</h2>
<p>
Generally, problem is solved. But in future we may want to have more than two
windows and with more harder callbacks logic. Let's try encapsulate window
managment inside class for more scalability.<br>
Make step backward to single window problem and implement class with same usage.
</p>

<pre><code>
class GLView {
 public:
   GLView(const char* title);

 private:
   static void display();
};
</code></pre>

<p>
Header of our class has all that we need. User choose window title only.
Now main function use single line for create similar window. In sight of class
user it is easy to use without care about internal implementation.
</p>

<pre><code>
int main(int argc, char** argv) {
  GLView glview("Single view");
  glutMainLoop();
  return 0;
}
</code></pre>

<p>
In sight of class we just encpsulated existing usage inside corresponding
methods. Note that functions is static. It is required for registering
callbacks.
</p>

<table>
  <td width="50%" valign="bottom">
  <pre><code>
  GLView::GLView(const char* title) {
    // GLUT initialization.
    int argc = 0;
    glutInit(&amp;argc, 0);

    // Window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    int window_id = glutCreateWindow(title);

    glutDisplayFunc(display);  // Set callback.
  }
  </code></pre></td>

  <td width="50%" valign="bottom">
  <pre><code>
  void GLView::display() {
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();

    glutSwapBuffers();
  }
  </code></pre></td>
</table>

<h2 id="two_glviews">Abstract views manager</h2>

<p>
We need to provide few windows management. Due to display function is static, it
is same for different class objects. But we need to separate displaying.<br>
Let's make display as abstract function that will be implemented inside
an inherited classes. As callback we calling each display of created window.
</p>

<pre><code>
class GLView {
 public:
   GLView(const char* title);

 protected:
   virtual void display() = 0;

 private:
   static void display_all();

   static std::vector&lt;GLView*&gt; glviews;
   int window_id;
};
</code></pre>

<p>
We will see that display_all function is registered as callback for each window
i.e. in case of single display request we redisplay every other window.
</p>

<table>
  <td width="50%" valign="bottom">
  <pre><code>
  GLView::GLView(const char* title) {
    if (glviews.empty()) {
      int argc = 0;
      glutInit(&amp;argc, 0);  // GLUT initialization.
    }

    // Window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    window_id = glutCreateWindow(title);
    glviews.push_back(this);

    glutDisplayFunc(display_all);  // Set callback.
  }
  </code></pre></td>

  <td width="50%" valign="top">
  <pre><code>
  void GLView::display_all() {
    for (int i = 0; i < glviews.size(); ++i) {
      glviews[i]->display();
    }
  }
  </code></pre></td>
</table>

Before we had different functions for different windows. Now we have problem
with window identification. If unroll a loop inside display_all method, only
last iteration is actual because it has own glClear(..) and glutSwapBuffers(..)
calls that overwrites previous changes.<br>
For solving problem we using glutSetWindow(..). It sets current window for
which applying future commands.

<pre><code>
void GLView::display_all() {
  for (int i = 0; i < glviews.size(); ++i) {
    glutSetWindow(glviews[i]->window_id);
    glviews[i]->display();
  }
}
</code></pre>

<p>
For new window we implements class with own display.
</p>

<table>
  <td width="50%" valign="bottom">
  <pre><code>
  class FirstView : public GLView {
   public:
    FirstView() : GLView("First view") {}

   protected:
     virtual void display() {
       glClear(GL_COLOR_BUFFER_BIT);

       glColor3ub(0xCA, 0xFF, 0xEE);
       glBegin(GL_TRIANGLES);
         glVertex2f(0.0f, 0.5f);
         glVertex2f(-0.5f, -0.5f);
         glVertex2f(0.5f, -0.5f);
       glEnd();

       glutSwapBuffers();
     }
  };
  </code></pre></td>

  <td width="50%" valign="bottom">
  <pre><code>
  class SecondView : public GLView {
   public:
    SecondView() : GLView("Second view") {}

   protected:
     virtual void display() {
       glClear(GL_COLOR_BUFFER_BIT);

       glColor3ub(0xCA, 0xFF, 0xEE);
       glBegin(GL_TRIANGLES);
         glVertex2f(0.0f, -0.5f);
         glVertex2f(0.5f, 0.5f);
         glVertex2f(-0.5f, 0.5f);
       glEnd();

       glutSwapBuffers();
     }
  };
  </code></pre></td>
</table>

<h2 id="subwindows">GLUT subwindows</h2>
<p>
In addition let's try merge two windows inside single window. But each subwindow
has own callbacks.<br>
GLUT has method glutCreateSubWindow(..) which creates new window in space of
existing parent window.
</p>

<pre><code>
GLView::GLView(const char* title, GLView* parent) {
  if (glviews.empty()) {
    int argc = 0;
    glutInit(&amp;argc, 0);  // GLUT initialization.
  }

  // Window initialization.
  if (parent != 0) {
    // Receive parent's id, x, y, width and height. Subwindows has not titles.
    window_id = glutCreateSubWindow(parent->window_id, 0, 0, 128, 128);
  } else {
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    window_id = glutCreateWindow(title);
  }
  glviews.push_back(this);

  glutDisplayFunc(display_all);  // Set callback.
}
</code></pre>

<img src="images/subwindow.png" alt="Subwindow"><br>

<p>
Addition: subwindow has constant shape although parent size changes. If needed,
we can make own child reshape using relative coordinates and parent's reshape
callback.
</p>

<h2 id="references">Useful links</h2>
<a href=https://www.opengl.org/sdk/docs/man2/xhtml>OpenGL 2.1 Reference Pages</a><br>
<a href=http://freeglut.sourceforge.net/docs/api.php>freeglut API</a>

</body>
</html>
