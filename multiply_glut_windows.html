<!DOCTYPE html>
<html>

<head>
  <title>DK: Multi GLUT</title>
</head>

<body>

<h1><a href="index.html">Dmitry Kurtaev/</a> C++: Multiply GLUT windows</h1>
<p>
<b>Problem:</b> use separate GLUT windows with own callbacks and drawing functions.<br>
<b>Example:</b> written on C++, freeglut.<br>
</p>
<p>

<h2>Single classic window</h2>
GLUT is a library for OpenGL.
It provides windows manipulations: create, reshape, receive user's callbacks and
display OpenGL's buffers.<br>
Minimal usage includes GLUT and window initialization, settings up references to
functions which we want to be called by specific events.
There are callbacks.<br>
Idle function is a function which must be called when no events exists. We set
display function as Idle.
</p>

<table>
  <td width="50%" valign="bottom">
  <pre>
  #include &lt;GL/freeglut.h&gt;

  int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);  // GLUT initialization.

    // Window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    int window_id = glutCreateWindow("Single view");

    // Set callbacks.
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutIdleFunc(display);

    glutMainLoop();  // Start GLUT's internal loop. Exit by window closing.
    return 0;
  }
  </pre></td>

  <td width="50%" valign="bottom">
  <pre>
  void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);  // Hex just for fun. Color is (202, 255, 238).
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();

    glutSwapBuffers();
  }

  void reshape(int width, int height) {
    glViewport(0, 0, width, height);
  }
  </pre></td>
</table>

<p>
Created window inherits OS's windows style.
At pictures example runned on Ubuntu 16.04LTS.<br>
<img src="images/single_window_triangle.png" alt="Single view"><br>
Addition: GLUT is a powerful but simple windows manager. We can not make some
OS-like operations like hiding window's header or keep window always on top of
other windows.
</p>

<h2>Two classic windows</h2>
<!-- Давайте подумаем о создании второго окна, отображающего иное содержимое.
Посмотрите внимательнее на пример выше. Мы назвали его минимальным, но это не
совсет так. Переменная window_id, получающая идентификатор окна от функции
glutCreateWindow(), нигде более не используется.
Русскому писателю Антону П. Чехову принадлежит высказывание
"Если в первом акте зрителю демонстрируется ружьё, значит во втором акте это
ружьё выстрелит.".
Приглашаю во второй акт, переменная window_id - и есть наше ружьё, которым мы
воспользуемся при решении поставленной задачи. -->
<!-- <p>
Let's think about a couple of windows managing. I write that code above is
minimal for running our application but it is not completely true. See
</p> -->

<!-- Проинициализируем последовательно два окна, каждое свяжем с собственной
функцией отрисовки. -->
We initializing two windows sequently. For each write own display function.
Before display instructions call glutSetWindow(..) with passed id of
 <!-- С id окна, в котором будет производиться перерисовка. -->
<!-- Обратить внимание на то, что два дисплея и один reshape. Для нашего примера,
изменение размера окна происходит только от лица пользователя. Перед этим,
пользователь выделяет окно как текущее, поэтому нам не нужно переключаться автоматически.
GLUT имеет функционал по программному запросу изменения размеров окна. В таком случае
и выделение окна как текущего требуется программное. -->
<!-- Посколько функии отрисовки объявлены как Idle, они исполняются циклично: когда
окно активно, скрыто или находится на заднем плане. См. рисунок, First View выделено,
Second View нет. Находясь в едином контексте, необходимо предварительно переключиться
между окнами. Для reshape, переключение осуществляет пользователь, нажатием мыши.
Для display мы должны перерисовывать как текущее, выделенное, окно, так и все
созданные. -->
<!-- Add second id and switch between. Tell about single reshape. What if number of view more than two? Additional ids?<br> -->
<table>
  <td width="50%" valign="bottom">
  <pre>
  int first_window_id, second_window_id;

  int main(int argc, char** argv) {
    glutInit(&amp;argc, argv);  // GLUT initialization.

    // First window initialization.
    glutInitWindowSize(324, 324);  // Width, height of window.
    glutInitWindowPosition(0, 0);  // (x, y) position of window from top-left.
    first_window_id = glutCreateWindow("First view");

    glutDisplayFunc(display_first);
    glutReshapeFunc(reshape);
    glutIdleFunc(display_first);

    // Second window initialization.
    glutInitWindowSize(324, 324);
    glutInitWindowPosition(500, 0);
    second_window_id = glutCreateWindow("Second view");

    glutDisplayFunc(display_second);
    glutReshapeFunc(reshape);
    glutIdleFunc(display_second);

    glutMainLoop();  // Exit from GLUT's loop by one of windows is closing.
    return 0;
  }

  void reshape(int width, int height) {
    glViewport(0, 0, width, height);
  }
  </pre></td>

  <td width="50%" valign="bottom">
  <pre>
  void display_first() {
    glutSetWindow(first_window_id);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, 0.5f);
      glVertex2f(-0.5f, -0.5f);
      glVertex2f(0.5f, -0.5f);
    glEnd();

    glutSwapBuffers();
  }

  void display_second() {
    glutSetWindow(second_window_id);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3ub(0xCA, 0xFF, 0xEE);
    glBegin(GL_TRIANGLES);
      glVertex2f(0.0f, -0.5f);
      glVertex2f(0.5f, 0.5f);
      glVertex2f(-0.5f, 0.5f);
    glEnd();

    glutSwapBuffers();
  }
  </pre></td>
</table>

<img src="images/two_windows_classic.png" alt="Two views"><br>

<!-- Задачу можно считать решенной. Однако предложенный подход иммет ряд нестотатков. Во первых,
присутствуют повторяющиеся участки кода, что ухудшает читаемость. Во вторых, при
необходимости добавление большего числа окон, потребуется снова вводить дополнительный
id, . Функционал каждого из окон может расти. Применим ООП для выделения сущности GLView,
пользователю которого интересует лишь title.  -->
<!-- Обернём весь имеющийся функционал в класс GLView: -->
<h2>Single window as class object</h2>
<pre class="brush: cpp">
class GLView {
 public:
   GLView(const char* title);

 private:
   static void display();
   static void reshape(int width, int height);
};
</pre>

</body>
</html>
