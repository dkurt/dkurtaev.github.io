<!DOCTYPE html>
<html lang="ru">

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<head>
  <title>DK: Heights map</title>
</head>

<body>

<h1><a href="index_ru.html">Dmitry Kurtaev/</a> C++: Grid surface using heights map</h1>
<p>
<b>Задача:</b> изображение трёхмерной поверхности, заданной на сетке.<br>
<b>Пример:</b> с использованием C++, freeglut.<br>
<b>Языки:</b>
<a href="grid_surface_ru.html">RU</a>
</p>

<p>
Пусть в пространстве (x, y, z) задана сеточная функция: узлы в плоскости (x, y)
и значения высот (координат z) для каждого из узлов.
</p>

<h2>Подготовка</h2>
<p>
Сделаем основание для будущей работы: отобразим координатные оси.<br>
Для ориентации в трехмерном пространстве, отобразим координатные оси.
Плоскость координат (x, y) будем считать осонованием, а по оси координат z
откладывать значения функции, задающей поверхность.<br>
Перед началом рисования, необходимо задать положение камеры в пространстве.
<!-- Изображение камеры, с осью -->
</p>

<table>
  <td width="50%" valign="top">
    <script src="code_samples/grid_surface_draw_axises.cpp"></script>
  </td>

  <td width="50%" valign="top">
    <img src="images/grid_surface_coord_axises.png" alt="Coordinate axises"><br>
  </td>
</table>

<h2>Задание поверхности</h2>
<table>
  <td width="50%" valign="top">
  <pre><code>
     ^ y
  y3 |   *-----*-----*-----*-----*  min_x = x0; max_x = x4
     |   |     |     |     |     |  min_y = y0; max_y = y3
     |   |     |     |     |     |  n_nodes_by_x = 5
     |   |     |     |     |     |  n_nodes_by_y = 4
  y2 |   *-----*-----*-----*-----*
     |   |     |     |     |     |
     |   |     |     |     |     |
     |   |     |     |     |     |
  y1 |   *-----*-----*-----*-----*
     |   |     |     |     |     |
     |   |     |     |     |     |
     |   |     |     |     |     |
  y0 |   *-----*-----*-----*-----*
     +-------------------------------> x
         x0    x1    x2    x3    x4
  </code></pre></td>

  <td width="50%" valign="top">
  <pre><code>
                                         ^ z
                                         |
                                         |
                 f(x3, y1)               |
                @              f(x1, y0) |
                |              @         |
                |              |         |
             x4 |  x3    x2    | x1  x0  |
       x <------|--------------|---------+
             *--|--*-----*-----*-----*  / y0
            /   | /     /     /     /  /
           /    |/     / @ f(x1, y2)  /
          *-----*-----*--|--*-----*  / y1
         /     /     /   | /     /  /
        /     /     /    |/     /  /
       *-----*-----*-----*-----*  / y2
      /     /     /     /     /  /
     /     /     /     /     /  /
    *-----*-----*-----*-----*  / y3
                            y v
    </code></pre></td>
</table>

<p>
Для описания поверхности как множества точек пространства (x, y, z), зададим
равномерную сетку в плоскости (x, y). Сетка называется равномерной, если
расстояние между соседними узлами, вдоль каждой из осей, не изменяется.<br>
В каждом из узлов известна координата z как функция от (x, y): z = f(x, y).
Будем называть это значение высотой. Множество значений высот для всех узлов
сетки будем называть картой высот.
</p>

<h2>Поверхность как множество точек</h2>
<p>
Создадим некоторую поверхность по известному закону f(x, y). Для начала,
изобразим точки поверхности сферами.
</p>

<table>
  <tr height="50%">
    <td width="50%" valign="top">
      <script src="code_samples/grid_surface_via_spheres_header.cpp"></script>
    </td>

    <td width="50%" valign="top">
      <img src="images/grid_surface_via_spheres.png" alt="Surface via spheres"><br>
    </td>
  </tr>

  <tr height="50%">
    <td width="50%" valign="top">
      <script src="code_samples/grid_surface_via_spheres_constructor.cpp"></script>
    </td>

    <td width="50%" valign="top">
      <script src="code_samples/grid_surface_via_spheres_draw.cpp"></script>
    </td>
  </tr>
</table>

<h2>Триангуляция</h2>
<p>
Для рисования сплошной поверхности, необходимо осуществить рисование примитивов
с вершинами в узлах сетки. Разобьём пространство между вершинами на
треугольники.<br>
Поскольку вся необходимая информация содержится в массиве с координатами,
изменяем только функцию отрисовки.
</p>

<table>
  <td width="50%" valign="top">
  <pre><code>
     ^ y
  y3 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y2 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y1 |   *-----*-----*-----*-----*
     |   |   / |   / |   / |   / |
     |   |  /  |  /  |  /  |  /  |
     |   | /   | /   | /   | /   |
  y0 |   *-----*-----*-----*-----*
     +-------------------------------> x
         x0    x1    x2    x3    x4
  </code></pre></td>

  <td width="50%" valign="top">
  <pre><code>
  (x,y+dy) ____top____(x+dx,y+dy)
          |  <--     /|
          | |   ^   / |
          | v   |  /  |
         l|  -->  /   |r
         e|      /    |i
         f|     /     |g
         t|    / <--  |h
          |   / |   ^ |t
          |  /  V   | |
          | /    -->  |
          |/__________|
      (x,y)  bottom (x+dx,y)
    </code></pre></td>
</table>

<table>
  <td width="50%" valign="top">
    <script src="code_samples/grid_surface_via_triangles_draw.cpp"></script>
  </td>

  <td width="50%" valign="top">
    <img src="images/grid_surface_via_triangles.png" alt="Surface via triangles"><br>
  </td>
</table>

Вычисление нормалей.
<pre><code>
y+dy  _____z6___z5
     |***/ | 5 / |
     |**/  |  /  |
     |*/ 6 | / 4 |
   y z1---z0----z4
     | 1 / | 3 /*|
     |  /  |  /**|
     | / 2 | /***|
y-dy z2----z3----*
    x-dx   x    x+dx

1) nx = dy*(z1-z0); ny = dx*(z2-z1); nz = dx*dy;
2) nx = dy*(z2-z3); ny = dx*(z3-z0); nz = dx*dy;
3) nx = dy*(z0-z4); ny = dx*(z3-z0); nz = dx*dy;
4) nx = dy*(z0-z4); ny = dx*(z4-z5); nz = dx*dy;
5) nx = dy*(z6-z5); ny = dx*(z0-z6); nz = dx*dy;
6) nx = dy*(z1-z0); ny = dx*(z0-z6); nz = dx*dy;

nx = 1/6 * dy * (2*z1+z2-z3-2*z4-z5+z6)
ny = 1/6 * dx * (-z1+z2+2*z3+z4-z5-2*z6)
nz = dx*dy
</code></pre>

</body>

</html>
